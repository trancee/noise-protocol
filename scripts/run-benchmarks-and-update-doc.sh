#!/usr/bin/env bash
set -euo pipefail

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
android_log="$(mktemp)"
ios_log="$(mktemp)"
trap 'rm -f "$android_log" "$ios_log"' EXIT

echo "[bench] Running Android benchmark tests..."
(
  cd "$repo_root/android"
  gradle --no-daemon --console=plain :noise-core:test :noise-crypto:test --tests '*Benchmark*' >"$android_log"
)

android_core_xml="$repo_root/android/noise-core/build/test-results/test/TEST-dev.noiseprotocol.core.NoiseCoreBenchmarkTest.xml"
android_crypto_xml="$repo_root/android/noise-crypto/build/test-results/test/TEST-dev.noiseprotocol.crypto.CryptoProviderBenchmarkTest.xml"

echo "[bench] Running iOS benchmark tests..."
(
  cd "$repo_root/ios"
  swift test --filter NoiseCoreTests >"$ios_log"
)

python3 - "$repo_root" "$android_core_xml" "$android_crypto_xml" "$ios_log" <<'PY'
from __future__ import annotations

import sys
import xml.etree.ElementTree as ET
from datetime import datetime, timezone
from pathlib import Path

repo_root = Path(sys.argv[1])
android_core_xml = Path(sys.argv[2])
android_crypto_xml = Path(sys.argv[3])
ios_log = Path(sys.argv[4])
doc_path = repo_root / "docs" / "Benchmark_Test_Results.md"

def read_android_benchmark_lines(paths: list[Path]) -> list[str]:
    lines: list[str] = []
    for path in paths:
        if not path.exists():
            raise SystemExit(f"[bench] Missing Android benchmark result file: {path}")
        text = ET.parse(path).getroot().findtext("system-out") or ""
        lines.extend(
            line.strip() for line in text.splitlines() if line.strip().startswith("benchmark ")
        )
    return sorted(lines)


def read_ios_benchmark_lines(path: Path) -> list[str]:
    if not path.exists():
        raise SystemExit(f"[bench] Missing iOS benchmark log: {path}")
    lines = []
    for line in path.read_text(encoding="utf-8").splitlines():
        stripped = line.strip()
        if stripped.startswith("NoiseCore benchmark"):
            lines.append(stripped)
    return sorted(lines)


android_lines = read_android_benchmark_lines([android_core_xml, android_crypto_xml])
ios_lines = read_ios_benchmark_lines(ios_log)

if not android_lines:
    raise SystemExit("[bench] No Android benchmark lines found in benchmark test output.")
if not ios_lines:
    raise SystemExit("[bench] No iOS benchmark lines found in benchmark test output.")

timestamp = datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

android_block = "\n".join(android_lines)
ios_block = "\n".join(ios_lines)

content = f"""# Benchmark Test Results

This document is auto-generated by `scripts/run-benchmarks-and-update-doc.sh`.

Run timestamp (UTC): `{timestamp}`
Scope: all available Android and iOS benchmark variations currently implemented in test suites.

## Commands used

```bash
# Android
cd android
gradle --no-daemon --console=plain :noise-core:test :noise-crypto:test --tests '*Benchmark*'

# iOS
cd ios
swift test --filter NoiseCoreTests
```

## Results

### Android benchmark lines

Sources:
- `android/noise-core/build/test-results/test/TEST-dev.noiseprotocol.core.NoiseCoreBenchmarkTest.xml`
- `android/noise-crypto/build/test-results/test/TEST-dev.noiseprotocol.crypto.CryptoProviderBenchmarkTest.xml`

```text
{android_block}
```

### iOS benchmark lines

Source:
- `swift test --filter NoiseCoreTests` output

```text
{ios_block}
```

## Notes

- These numbers are environment-dependent and should be treated as relative indicators, not fixed targets.
- Always run `scripts/run-benchmarks-and-update-doc.sh` so the benchmark document stays in sync with the latest run.
- For CI and interop validation commands, see `README.md` and `docs/Noise_Test_Harness.md`.
"""

doc_path.write_text(content, encoding="utf-8")
print(f"[bench] Updated {doc_path}")
PY

echo "[bench] Benchmark tests completed and document refreshed."
